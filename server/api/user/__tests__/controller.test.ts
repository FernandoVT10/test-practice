import controller from "../controller";
import service from "../service";
import bcrypt from "bcrypt";
import jwtHelpers from "../../../utils/jwtHelpers";

import { ValidationError } from "../../../utils/errors";

describe("api/user/controller", () => {
  beforeEach(() => jest.resetAllMocks());

  describe("createUser", () => {
    const { createUser } = controller;

    const data = {
      username: "foo",
      password: "secret"
    };

    const createOneUserSpy = jest.spyOn(service, "createOneUser");

    beforeEach(() => {
      createOneUserSpy.mockResolvedValueOnce({} as any);

      jest.spyOn(bcrypt, "hash")
        .mockImplementationOnce(() => Promise.resolve("hashed password"));
    });

    it("should return a successful message", () => {
      return expect(createUser(data)).resolves.toEqual({
        message: "User was registered successfully"
      });
    });

    it("should hash the password before sending it to the createOneUser", async () => {
      await createUser(data);

      expect(createOneUserSpy).toHaveBeenCalledWith(expect.objectContaining({
        password: "hashed password"
      }));
    });
  });

  describe("getAuthToken", () => {
    const { getAuthToken } = controller;

    const findUserByUsernameSpy = jest.spyOn(service, "findUserByUsername");

    const userData = {
      username: "user",
      password: "pass"
    };

    const userMock = {
      _id: 1,
      username: userData.username,
      password: bcrypt.hashSync(userData.password, 1)
    };

    beforeEach(async () => {
      findUserByUsernameSpy.mockResolvedValueOnce(userMock as any);
    });

    it("should throw a ValidationError when findUserByUsername returns null", () => {
      findUserByUsernameSpy.mockReset().mockResolvedValueOnce(null);

      return expect(getAuthToken(userData)).rejects.toThrowError(
        new ValidationError(404, "Username or password are invalid")
      );
    });

    it("should throw a ValidationError when the password is incorrect", () => {
      const incorrectData = {
        username: "user",
        password: "1234"
      };

      return expect(getAuthToken(incorrectData)).rejects.toThrowError(
        new ValidationError(404, "Username or password are invalid")
      );
    });

    it("should return the token generated by jsonwebtoken", () => {
      const token = "dummy token";

      jest.spyOn(jwtHelpers, "signToken").mockReturnValueOnce(token as any);

      return expect(getAuthToken(userData)).resolves.toEqual(token);
    });
  });
});
